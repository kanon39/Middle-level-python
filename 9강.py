# 시퀀스를 통해서 다양한 파이썬 데이터 타입에 대해 배워보고 있다.
# 해시 테이블을 배우고 딕셔너리를 생성하는 방법 중에
# 센스있게 키를 하나로 합치면서 데이터를 추가하는 방법을 배워보겠다.

# 그 중에서 setdefault를 사용하겠다.

# 오픈 소스를 보면 튜플을 굉장히 많이 사용한다.
# 튜플 리스트로 바꾸는건 쉽지만 딕셔너리를 바꿀 떄 키를 하나로 통일을 하면서
# 딕셔너리로 만드는 경우가 있다. 이럴 때 오늘 배울 내용을 알면 손쉽게 할 수 있게된다.

# 해시테이블 : 해시값이 중복되었을 경우 중복 처리 방법 등을 아마존 등 개발 직무면접에서 많이 묻는다.
# key에 value를 저장하는 구조를 해시테이블이라 부른다.
# 파이썬자체가 강력한 해시테이블엔진으로 만들어졌다 소개되고있다.
# __dict__로 봤을때 key, value 형태로 print문을 출력해봤다.
# 키를 통해서 데이터를 저장하기 때문에 키가 중복되선 안된다.
# 예를 들어 주민번호가 중복되어 서로다른 사람을 저장해선 안될것이다.
# 파이썬 dict 해쉬테이블의 예다. 
# 해쉬는 고유로된 숫자로된 값을 의미한다. 이 고유된 값이 중복이 되지 않는다.
# 왜쓸까? 키 값의 연산 결과에 따라 직접 접근이 가능한 구조이기 때문이다.
# 만약 1억건의 DB중 여자 이씨를 찾는다하면 주민등록번호 뒷자리 2와 4를 찾을것이다.
# 키에서 고유한 특징을 추출해서 고유한 값으로 다이렉트로 찾아가기 때문에
# 해쉬테이블은 굉장히 중요하다.

# 파이썬에서는 해쉬를 별도로 구현할 필요없다. dict을 쓰면된다.
# 따라서 정리하면 key 값을 해싱 함수를 통해서 해쉬 주소값이 나오고
# 이 주소를 기반으로 키에 대한 value의 위치를 알 수 있다.

# Dict 구조
# 파이썬의 기본 내장된 정보를 볼때 __builtins__를 본다.
# 여기서는 예외가 발생하나 __builtins__.__dict__ 로하면
# 딕셔너리 타입으로 키, value로 이루어져 있다.
#print(__builtins__)


# 조금만 깊게 생각해보자.
# Hash 값 확인
t1 = (10,20,(30,40,50)) # 튜플은 불변하기 때문에 hash값도 고유하다.
t2 = (10,20,[30,40,50])
# 해쉬값이 출력됨
print(hash(t1)) 
# 리스트는 해쉬값을 뽑을 수 없다는 에러발생
# 즉 해쉬함수를 사용하려면 불변형이어야 한다. -> 오늘의 핵심
#print(hash(t2)) 

# 키가 중복되어 있을 때 Dict Setdefult 예제
# 튜플에서 딕셔너리 만들 때 속도향상도 빠르고 대용량 데이터를 처리,
# 분석에서 많이 사용되고 있다는걸 활용되고 있다.
# 아래와 같이 튜플형으로 구성되어 있는걸 딕셔너리로 바꾸고 싶다하자.
# 즉 값을 통합하고 싶은 것이다.
# 이때 k1,k2로 키를 쓰면 키 중복이 발생할 것이다.
source = (('k1','val1'),
          ('k1','val2'),
          ('k2','val3'),
          ('k2','val4'),
          ('k2','val5')
          )

new_dict1 = {}
new_dict2 = {}

# Setdefault 사용하지 않을 때
for k, v in source :
    # k에 k1이들어오고 v는 val1 이 들어올 것이다.
    if k in new_dict1 :
        new_dict1[k].append(v)
    else :
        new_dict1[k] = [v]
print(new_dict1)
# Setdefault 사용할 때
for k, v in source :
    # default로 키값은 앞의 k를 사용할 꺼야
    # 그리고 나머지 값들은 리스트로 담을 꺼야 
    # 이 리스트에 v를 담을 꺼야
    new_dict2.setdefault(k, []).append(v) #append는 리스트로만 반환하므로 튜플로바꾸면 에러발생함
print(new_dict2)


# 주의 
# 딕셔너리 컴프리핸션으로도 되는가?
# 이렇게 만들면 안된다.
new_dict3 = {k: v for k, v in source}
# 키가 중복일 경우 나중값으로 덮어쓰기 때문이다.
print(new_dict3)

print()
print()




