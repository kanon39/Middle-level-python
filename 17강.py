# 병렬성(Parallelism) : 여러 컴퓨터가 여러 작업을 동시에 수행
# -> 여러 프로세스나 워커가 동시에 수행
# -> CPU는 하나지만 여러일을 동시에 해내는 코루틴 등이 있다.
# -> 속도
# 코루틴은 하나의 흐름에서 다양한 작업이 가능했다면 
# 병렬성, 동시성(Futures)은 여러개의 작업을 동시에 처리할 수 있는,
# 또는 한개의 작업을 분할해서 여러개가 도와서 처리할 수 있다.

# Process와 Thread는 별도의 책이 필요한 지식이 필요하다.
# 코딩의 양보다는 이론적 지식이 뒷바탕이 되는 파트이다.

# Futures 병렬성
# https://docs.python.org/ko/3/library/concurrent.futures.html
# 코딩의 양은 별로 안되지만 이론적으로 생각해 볼 게 정말 많고
# 테스트를 해보고 이게 안정화가 되는지,
# 많은 테스트를 통해서 서비스를 오픈해도 될거야 라는 정도까지 가려면 많은시간이 필요로 하는 파트다.
# 모든 언어에서 이쪽 부분은 매우매우매우 중요하다.
# 시니어와 주니어의 실력 경계점을 나눌 수 있는 파트이다.
# 이거와 관련된 책들이 정말 많다.
# 하지만 파이썬은 쉽게 사용이 가능하다.
# 이 강의에서는 이론을 깊게 들어가기보다는
# 파이썬에서 제공하는 메소드를 생각해보고 예제를 만들어 보자.
 
# 비동기 작업 실행
# 동기란 A란 작업이 끝나기전까지 B가 실행될 순 없다. 이게 동기다.
# 비동기는 A도 작업을 걸고 B도 바로 작업을 걸 수 있다.
# 지연시간(Block) CPU 및 리소스 낭비 방지 -> (file) network I/O(Input 및 output)할때 동시성 활용 권장한다.

# 파이썬은 단일 프로그램으로 해도 충분히 빠르기 때문에 굉장히 효율적인 코드가가능하다.
# 비동기 작업과 적합한 프로그램일 경우 압도적으로 성능 향상되고 웹서버 등이 비동기로 처리가 된다.

# 2가지 패턴 실습
# concurrent futures 가 나오기전엔 굉장히 어려웠다.
# import threading, multiprocessing 둘다 써야되나 굉장히 복잡했다.
# 쎄마포어 경쟁상태의 해결 등 코드가 복잡했다.
# 이들을 랩핑한 futures 패키지가 나온 것이다.
# futures : 비동기 실행을 위한 API를 고수준으로 작성 -> 사용하기 쉽도록 개선

# concurrent.futures
# 1. 멀티스레딩/멀티프로세스 API 통일 -> 매우 사용하기 쉬움
# -> 예전에는 멀티스레딩, 멀티프로세스 따로따로 코딩을 했었어야 했다.
# -> 멀티스레딩을 멀티 프로세스로 바꾸는데 딱 한줄이면 된다.

# 2. 실행중인 작업 취소, 완료 여부 체크, 타임아웃 옵션, 콜백추가, 동기화 코드 매우 쉽게 작성
# -> promise 개념(나중에 알아도 됨, 비동기 promise라 치면나옴)

# GIL : 길은 파이썬에만 있는 독특한것이다.
# 파이썬 글로벌 인터프리터 락(GIL), 여러개의 작업을 처리할 때 전체가 락이 걸리는 현상
# 만약에 2개 이상의 스레드가 동시에 실행 될 때 하나의 자원을 엑세스 하는 경우
# -> 문제점을 방지하기 위해 GIL이 실행됨. 즉 리소스 전체에 락이 걸린다.
# -> 락이 걸림과 context switch(문맥 교환, 10명이 일하면 하나로 합치는) 비용이 든다.
# -> 운영체제에서도 가만히 안내비둠, 자원을 많이 할당하지 않음
# -> 오히려 스레드 하나가 달라붙는것보다 여러 스레드가 달라붙는게 느릴 수 있다.
# -> 따라서 적합한 프로그래밍 로직을 쓰는게 맞음.
# -> 결론 : 스레드 많이 쓴다고 좋지 않음. GIL 떄문.
# 예) 멀티프로세싱이 필요로한다면 프로세싱으로 작업을 한다거나
# 예) 단순 덧셈, 뺄셈을 더하고 취합하는 거라면 스레드는 훌륭한 작업이 될 것이다.

# GIL 을 우회하는 법 : 멀티프로세싱 사용, CPython 활용
 

# concurrent.futures 사용법1
# concurrent.futures 사용법2


import os
import time
from concurrent import futures

# 1부터 만, 십만, 백만, 천만까지의 합을 구해보자.
WORK_LIST = [10000, 100000, 1000000, 10000000]

# 순차적으로 처리한다면 만구하고, 십만, 백만, 천만을 구해야하나
# 동시에 worker를 해서 각각 실행시켜 보겠다.
# 여기에 우리가 만든 함수를 리스트에 넣고 응용해도 된다.

# 동시성 합계 계산 메인 함수
# 누적 합계 함수(제레네이터)
def sum_generator(n) :
    return sum( n for n in range (1, n+1))
# 이 함수가 동시에 4개가 실행이 된다.
# worker :
# 작업자로는 스레드를 활용할 수도있고
# CPU의 프로세서를 활용할 수도 있다.

def main() :
    # Worker count 몇 명이서 일할 건데?
    # 몇명인지 모르면 OS에 맡겨도됨.
    # 리스트 작업 량에 따라 값지정, 최소 10개 이하
    worker = min(10, len(WORK_LIST))
    
    # 시작 시간
    start_tm = time.time() # 시작 시간
    
    # 결과 건수
    # 여기가 중요! 
    # 프로세스를 활용할 것이면 ProcessPoolExecutor 를,
    # 스레드를 활용할 것이면 ThreadPoolExecutor 를 실행한다.
    # 연산할 떄는 딥러닝과같은 경우 CPU가 더 빠르다. 
    # 아래 두줄 넣은게 끝.
    with futures.ProcessPoolExecutor() as excutor : #별칭 달기
        # map은 작업순서를 유지하고 즉시 실행한다.
        # 짝을맞추기위해 작업할 함수와 작업목적 리스트의 map을 활용.
        result = excutor.map(sum_generator, WORK_LIST)
     
    # 종료 시간
    end_tm = time.time() - start_tm
    # 출력 포맷
    msg = '\n Result -> {} Time : {:.2f}s'    
    # 최종 결과출력
    print(msg.format(list(result), end_tm))

# 지금까지는 실행을 그냥했지만
# 이제는 main 함수의 진입점을 알려줘야 됨

if __name__ =='__main__' : # 시작점을 명시적으로 작성 안그러면 멀티프로세싱 작업시 실행 안됨.
   main()
   



